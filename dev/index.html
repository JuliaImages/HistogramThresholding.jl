<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HistogramThresholding.jl Documentation · HistogramThresholding</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HistogramThresholding</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>HistogramThresholding.jl Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>HistogramThresholding.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HistogramThresholding.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HistogramThresholding.jl-Documentation"><a class="docs-heading-anchor" href="#HistogramThresholding.jl-Documentation">HistogramThresholding.jl Documentation</a><a id="HistogramThresholding.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#HistogramThresholding.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Otsu" href="#HistogramThresholding.Otsu"><code>HistogramThresholding.Otsu</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Otsu())
t = find_threshold(img, Otsu(); nbins = 256)</code></pre><p>Under the assumption that the histogram is bimodal the threshold is set so that the resultant between-class variance is maximal.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the histogram. Then the probability that an observation belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>The choice of a threshold <span>$T$</span> partitions the data into two categories, <span>$C_0$</span> and <span>$C_1$</span>. Let</p><p class="math-container">\[P_0(T) = \sum_{i = 1}^T p_i \quad \text{and} \quad P_1(T) = \sum_{i = T+1}^I p_i\]</p><p>denote the cumulative probabilities,</p><p class="math-container">\[\mu_0(T) = \sum_{i = 1}^T i \frac{p_i}{P_0(T)} \quad \text{and} \quad \mu_1(T) = \sum_{i = T+1}^I i \frac{p_i}{P_1(T)}\]</p><p>denote the means, and</p><p class="math-container">\[\sigma_0^2(T) = \sum_{i = 1}^T (i-\mu_0(T))^2 \frac{p_i}{P_0(T)} \quad \text{and} \quad \sigma_1^2(T) = \sum_{i = T+1}^I (i-\mu_1(T))^2 \frac{p_i}{P_1(T)}\]</p><p>denote the variances of categories <span>$C_0$</span> and <span>$C_1$</span>, respectively. Furthermore, let</p><p class="math-container">\[\mu = P_0(T)\mu_0(T) + P_1(T)\mu_1(T),\]</p><p>represent the overall mean,</p><p class="math-container">\[\sigma_b^2(T) = P_0(T)(\mu_0(T) - \mu)^2 + P_1(T)(\mu_1(T) - \mu)^2,\]</p><p>the between-category variance, and</p><p class="math-container">\[\sigma_w^2(T) = P_0(T) \sigma_0^2(T) +  P_1(T)\sigma_1^2(T)\]</p><p>the within-category variance, respectively.</p><p>Finding the discrete value <span>$T$</span> which maximises the function <span>$\sigma_b^2(T)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold). As it turns out, that threshold value is equal to the threshold decided by minimizing the within-category variances criterion <span>$\sigma_w^2(T)$</span>. Furthermore, that threshold is also the same as the threshold calculated by maximizing the ratio of between-category variance to within-category variance.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, Otsu())</code></pre><p><strong>Reference</strong></p><ol><li>Nobuyuki Otsu (1979). “A threshold selection method from gray-level histograms”. <em>IEEE Trans. Sys., Man., Cyber.</em> 9 (1): 62–66. <a href="http://dx.doi.org/doi:10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/otsu.jl#L1-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.MinimumIntermodes" href="#HistogramThresholding.MinimumIntermodes"><code>HistogramThresholding.MinimumIntermodes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Minimum(); maxiter = 8000)
t = find_threshold(img, Minimum(); nbins = 256)</code></pre><p>Under the assumption that the histogram is bimodal the histogram is smoothed using a length-3 mean filter until two modes remain. The threshold is then set to the minimum value between the two modes.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>If after <code>maxiter</code> iterations the smoothed histogram is still not bimodal then the algorithm will fall back to using the <code>UnimodalRosin</code> method to select a threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong><code>maxiter</code></strong></p><p>An <code>Int</code> that specifies the maximum number of smoothing iterations. If left unspecified a default value of 8000 is used.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, MinimumIntermodes())</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” <em>CVGIP: Graphical Models and Image Processing</em>, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li><li>J. M. S. Prewitt and M. L. Mendelsohn, “THE ANALYSIS OF CELL IMAGES<em>,” *Annals of the New York Academy of Sciences</em>, vol. 128, no. 3, pp. 1035–1053, Dec. 2006. <a href="https://doi.org/10.1111/j.1749-6632.1965.tb11715.x">doi:10.1111/j.1749-6632.1965.tb11715.x</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/minimum.jl#L1-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Intermodes" href="#HistogramThresholding.Intermodes"><code>HistogramThresholding.Intermodes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Intermodes(maxiter=8000))
t = find_threshold(img, Intermodes(); nbins = 256)</code></pre><p>Under the assumption that the histogram is bimodal the histogram is smoothed using a length-3 mean filter until two modes remain. The threshold is then set to the average value of the two modes.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>If after <code>maxiter</code> iterations the smoothed histogram is still not bimodal then the algorithm will fall back to using the <code>UnimodalRosin</code> method to select a threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong><code>maxiter</code></strong></p><p>An <code>Int</code> that specifies the maximum number of smoothing iterations. If left unspecified a default value of 1000 is used.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">
using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, Intermodes())</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/intermodes.jl#L1-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.MinimumError" href="#HistogramThresholding.MinimumError"><code>HistogramThresholding.MinimumError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, MinimumError())
t = find_threshold(img, MinimumError(); nbins = 256)</code></pre><p>Under the assumption that the histogram is a mixture of two Gaussian distributions the threshold is chosen such that the expected misclassification error rate is minimised.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the histogram. Then the probability that an observation belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>The minimum error thresholding method assumes that one can find a threshold <span>$T$</span> which partitions the data into two categories,  <span>$C_0$</span> and <span>$C_1$</span>, such that the data can be modelled by a mixture of two Gaussian distribution. Let</p><p class="math-container">\[P_0(T) = \sum_{i = 1}^T p_i \quad \text{and} \quad P_1(T) = \sum_{i = T+1}^I p_i\]</p><p>denote the cumulative probabilities,</p><p class="math-container">\[\mu_0(T) = \sum_{i = 1}^T i \frac{p_i}{P_0(T)} \quad \text{and} \quad \mu_1(T) = \sum_{i = T+1}^I i \frac{p_i}{P_1(T)}\]</p><p>denote the means, and</p><p class="math-container">\[\sigma_0^2(T) = \sum_{i = 1}^T (i-\mu_0(T))^2 \frac{p_i}{P_0(T)} \quad \text{and} \quad \sigma_1^2(T) = \sum_{i = T+1}^I (i-\mu_1(T))^2 \frac{p_i}{P_1(T)}\]</p><p>denote the variances of categories <span>$C_0$</span> and <span>$C_1$</span>, respectively.</p><p>Kittler and Illingworth proposed to use the minimum error criterion function</p><p class="math-container">\[J(T) = 1 + 2 \left[ P_0(T) \ln \sigma_0(T) + P_1(T) \ln \sigma_1(T) \right] - 2 \left[P_0(T) \ln P_0(T) + P_1(T) \ln P_1(T) \right]\]</p><p>to assess the discreprancy between the mixture of Gaussians implied by a particular threshold <span>$T$</span>, and the piecewise-constant probability density function represented by the histogram. The discrete value <span>$T$</span> which minimizes the function <span>$J(T)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, MinimumError())</code></pre><p><strong>References</strong></p><ol><li>J. Kittler and J. Illingworth, “Minimum error thresholding,” Pattern Recognition, vol. 19, no. 1, pp. 41–47, Jan. 1986. <a href="https://doi.org/10.1016/0031-3203%2886%2990030-0">doi:10.1016/0031-3203(86)90030-0</a></li><li>Q.-Z. Ye and P.-E. Danielsson, “On minimum error thresholding and its implementations,” Pattern Recognition Letters, vol. 7, no. 4, pp. 201–206, Apr. 1988. <a href="https://doi.org/10.1016/0167-8655%2888%2990103-1">doi:10.1016/0167-8655(88)90103-1</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/minimum_error.jl#L2-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Moments" href="#HistogramThresholding.Moments"><code>HistogramThresholding.Moments</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Moments())
t = find_threshold(img, Moments(); nbins = 256)</code></pre><p>The following rule determines the threshold:  if one assigns all observations below the threshold to a value z₀ and all observations above the threshold to a value z₁, then the first three moments of the original histogram must match the moments of this specially constructed bilevel histogram.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the histogram and <span>$z_i$</span> <span>$(i=1 \ldots I)$</span> the observed value associated with the <span>$i$</span>th bin.  Then the probability that an observation <span>$z_i$</span> belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>Moments can be computed from the histogram <span>$f$</span> in the following way:</p><p class="math-container">\[m_k = \frac{1}{N} \sum_i p_i (z_i)^k \quad k = 0,1,2,3, \ldots.\]</p><p>The principle of moment-preserving thresholding is to select a threshold value, as well as two representative values <span>$z_0$</span> and <span>$z_1$</span> (<span>$z_0 &lt; z_1$</span>), such that if all below-threshold values in <span>$f$</span> are replaced by <span>$z_0$</span> and all above-threshold values are replaced by <span>$z_1$</span>, then this specially constructed bilevel histogram <span>$g$</span> will have the same first three moments as <span>$f$</span>.</p><p>Concretely, let <span>$q_0$</span> and <span>$q_1$</span> denote the fractions of observations below and above the threshold in <span>$f$</span>, respectively. The constraint that the first three moments in <span>$g$</span> must equal the first three moments in <span>$f$</span> can be expressed by the following system of four equations</p><p class="math-container">\[\begin{aligned}
   q_0 (z_0)^0 + q_1 (z_1)^0   &amp; = m_0 \\
   q_0 (z_0)^1 + q_1 (z_1)^1   &amp; = m_1 \\
   q_0 (z_0)^2 + q_1 (z_1)^2   &amp; = m_2 \\
   q_0 (z_0)^3 + q_1 (z_1)^3   &amp; = m_3 \\
\end{aligned}\]</p><p>where the left-hand side represents the moments of <span>$g$</span> and the right-hand side represents the moments of <span>$f$</span>. To find the desired treshold value, one first solves the four equations to obtain <span>$q_0$</span> and <span>$q_1$</span>, and then chooses the threshold <span>$t$</span> such that <span>$q_0 = \sum_{z_i \le t} p_i$</span>.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, Moments())</code></pre><p><strong>Reference</strong></p><p>[1] W.-H. Tsai, “Moment-preserving thresolding: A new approach,” Computer Vision, Graphics, and Image Processing, vol. 29, no. 3, pp. 377–393, Mar. 1985. <a href="https://doi.org/10.1016/0734-189x%2885%2990133-1">doi:10.1016/0734-189x(85)90133-1</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/moments.jl#L1-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.UnimodalRosin" href="#HistogramThresholding.UnimodalRosin"><code>HistogramThresholding.UnimodalRosin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, UnimodalRosin())
t = find_threshold(img, UnimodalRosin(); nbins = 256)</code></pre><p>Generates a threshold assuming a unimodal distribution using Rosin&#39;s algorithm.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>This algorithm first selects the bin in the histogram with the highest frequency. The algorithm then searches from the location of the maximum bin to the last bin of the histogram for the first bin with a frequency of 0 (known as the minimum bin.). A line is then drawn that passes through both the maximum and minimum bins. The bin with the greatest orthogonal distance to the line is chosen as the threshold value.</p><p><strong>Assumptions</strong></p><p>This algorithm assumes that:</p><ul><li>The histogram is unimodal.</li><li>There is always at least one bin that has a frequency of 0. If not, the algorithm will use the last bin as the minimum bin.</li></ul><p>If the histogram includes multiple bins with a frequency of 0, the algorithm will select the first zero bin as its minimum. If there are multiple bins with the greatest orthogonal distance, the leftmost bin is selected as the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;moonsurface&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;moonsurface&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, UnimodalRosin())</code></pre><p><strong>Reference</strong></p><ol><li>P. L. Rosin, “Unimodal thresholding,” Pattern Recognition, vol. 34, no. 11, pp. 2083–2096, Nov. 2001.<a href="https://doi.org/10.1016/s0031-3203%2800%2900136-9">doi:10.1016/s0031-3203(00)00136-9</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/unimodal.jl#L1-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Entropy" href="#HistogramThresholding.Entropy"><code>HistogramThresholding.Entropy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">find_threshold(counts, edges, Entropy())
t = find_threshold(img, Entropy(); nbins = 256)</code></pre><p>An algorithm for finding the threshold value for a gray-level histogram using the entropy of the histogram.</p><p><strong>Output</strong></p><p>Returns the point in the <code>AbstractRange</code> which corresponds to the threshold bin in the histogram.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>This algorithm uses the entropy of a gray level histogram to produce a threshold value.</p><p>Let <span>$f_1, f_2, \ldots, f_I$</span> be the frequencies in the various bins of the histogram and <span>$I$</span> the number of bins. With <span>$N = \sum_{i=1}^{I}f_i$</span>, let <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>) denote the probability distribution of gray levels. From this distribution one derives two additional distributions. The first defined for discrete values <span>$1$</span> to <span>$s$</span> and the other, from <span>$s+1$</span> to <span>$I$</span>. These distributions are</p><p class="math-container">\[A: \frac{p_1}{P_s}, \frac{p_2}{P_s}, \ldots, \frac{p_s}{P_s}
\quad \text{and} \quad
B: \frac{p_{s+1}}{1-P_s}, \ldots, \frac{p_n}{1-P_s}
\quad \text{where} \quad
P_s = \sum_{i=1}^{s}p_i.\]</p><p>The entropies associated with each distribution are as follows:</p><p class="math-container">\[H(A) = \ln(P_s) + \frac{H_s}{P_s}\]</p><p class="math-container">\[H(B) = \ln(1-P_s) + \frac{H_n-H_s}{1-P_s}\]</p><p class="math-container">\[\quad \text{where} \quad
H_s = -\sum_{i=1}^{s}p_i\ln{p_i}
\quad \text{and} \quad
H_n = -\sum_{i=1}^{I}p_i\ln{p_i}.\]</p><p>Combining these two entropy functions we have</p><p class="math-container">\[\psi(s) = \ln(P_s(1-P_s)) + \frac{H_s}{P_s} + \frac{H_n-H_s}{1-P_s}.\]</p><p>Finding the discrete value <span>$s$</span> which maximises the function <span>$\psi(s)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p>See Section 4 of [1] for more details on the derivation of the entropy.</p><p><strong>Options</strong></p><p><strong>Choices for <code>counts</code></strong></p><p>You can specify an <code>AbstractArray</code> which should be a 1D array of frequencies for a histogram. You should submit the corresponding <code>edges</code> range for the bins of the histogram. The function will throw an error if it detects that the <code>edges</code> and <code>counts</code> have different lengths.</p><p><strong>Choices for <code>edges</code></strong></p><p>You can specify an <code>AbstractRange</code> which should be the corresponding range for the bins of the histogram array passed into <code>counts</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, Images

img = testimage(&quot;cameraman&quot;)
# building a histogram with 256 bins
edges, counts = build_histogram(img, 256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
find_threshold(counts[1:end], edges, Entropy())</code></pre><p><strong>References</strong></p><p>[1] J. N. Kapur, P. K. Sahoo, and A. K. C. Wong, “A new method for gray-level picture thresholding using the entropy of the histogram,” <em>Computer Vision, Graphics, and Image Processing</em>, vol. 29, no. 1, p. 140, Jan. 1985.<a href="https://doi.org/10.1016/s0734-189x%2885%2990156-2">doi:10.1016/s0734-189x(85)90156-2</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/entropy_thresholding.jl#L1-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Balanced" href="#HistogramThresholding.Balanced"><code>HistogramThresholding.Balanced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Balanced())
t = find_threshold(img, Balanced(); nbins = 256)</code></pre><p>In balanced histogram thresholding, one interprets a  bin as a  physical weight with a mass equal to its occupancy count. The balanced histogram method involves iterating the following three steps: (1) choose the midpoint bin index as a &quot;pivot&quot;,  (2) compute the combined weight to the left and right of the pivot bin and (3) remove the leftmost bin if the left side is the heaviest, and the rightmost bin otherwise. The algorithm stops when only a single bin remains. The last bin determines the sought-after threshold.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>Let <span>$f_n$</span> (<span>$n = 1 \ldots N$</span>) denote the number of observations in the <span>$n$</span>th bin of the histogram. The balanced histogram method constructs a sequence of nested intervals</p><p class="math-container">\[[1,N] \cap \mathbb{Z} \supset I_2 \supset I_3 \supset \ldots \supset I_{N-1},\]</p><p>where for <span>$k = 2 \ldots N-1$</span></p><p class="math-container">\[I_k = \begin{cases}
   I_{k-1} \setminus \{\min \left( I_{k-1} \right) \} &amp;\text{if } \sum_{n = \min \left( I_{k-1} \right)}^{I_m}f_n \gt   \sum_{n =  I_m + 1}^{ \max \left( I_{k-1} \right)} f_n, \\
   I_{k-1} \setminus \{\max \left( I_{k-1} \right) \} &amp;\text{otherwise},
\end{cases}\]</p><p>and <span>$I_m = \lfloor \frac{1}{2}\left(  \min \left( I_{k-1} \right) +  \max \left( I_{k-1} \right) \right) \rfloor$</span>. The final interval <span>$I_{N-1}$</span> consists of a single element which is the bin index corresponding to the desired threshold.</p><p>If one interprets a bin as a physical weight with a mass equal to its occupancy count, then each step of the algorithm can be conceptualised as removing the leftmost or rightmost bin to &quot;balance&quot; the resulting histogram on a pivot. The pivot is defined to be the midpoint between the start and end points of the interval under consideration.</p><p>If it turns out that the single element in <span>$I_{N-1}$</span> equals <span>$1$</span> or <span>$N$</span> then the original histogram must have a single peak and the algorithm has failed to find a suitable threshold. In this case the algorithm will fall back to using the <code>UnimodalRosin</code> method to select the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">
using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img, 256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, Balanced())</code></pre><p><strong>Reference</strong></p><ol><li>“BI-LEVEL IMAGE THRESHOLDING - A Fast Method”, Proceedings of the First International Conference on Bio-inspired Systems and Signal Processing, 2008. Available: <a href="https://doi.org/10.5220/0001064300700076">10.5220/0001064300700076</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/balancedthreshold.jl#L1-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.Yen" href="#HistogramThresholding.Yen"><code>HistogramThresholding.Yen</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = find_threshold(histogram, edges, Yen())
t = find_threshold(img, Yen(); nbins = 256)</code></pre><p>Computes the threshold value using Yen&#39;s maximum correlation criterion for bilevel thresholding.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> in <code>edges</code>. The <code>edges</code> parameter represents an <code>AbstractRange</code> which specifies the intervals associated with the histogram bins.</p><p><strong>Extended help</strong></p><p><strong>Details</strong></p><p>This algorithm uses the concept of <em>entropic correlation</em> of a gray level histogram to produce a threshold value.</p><p>Let <span>$f_1, f_2, \ldots, f_I$</span> be the frequencies in the various bins of the histogram and <span>$I$</span> the number of bins. With <span>$N = \sum_{i=1}^{I}f_i$</span>, let <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>) denote the probability distribution of gray levels. From this distribution one derives two additional distributions. The first defined for discrete values <span>$1$</span> to <span>$s$</span> and the other, from <span>$s+1$</span> to <span>$I$</span>. These distributions are</p><p class="math-container">\[A: \frac{p_1}{P_s}, \frac{p_2}{P_s}, \ldots, \frac{p_s}{P_s}
\quad \text{and} \quad
B: \frac{p_{s+1}}{1-P_s}, \ldots, \frac{p_n}{1-P_s}
\quad \text{where} \quad
P_s = \sum_{i=1}^{s}p_i.\]</p><p>The entropic correlations associated with each distribution are</p><p class="math-container">\[C(A) = -\ln \sum_{i=1}^{s} \left( \frac{p_i}{P_s} \right)^2 \quad \text{and} \quad C(B) = -\ln \sum_{i=s+1}^{I} \left( \frac{p_i}{1 - P_s} \right)^2.\]</p><p>Combining these two entropic correlation functions we have</p><p class="math-container">\[\psi(s) = -\ln \sum_{i=1}^{s} \left( \frac{p_i}{P_s} \right)^2 -\ln \sum_{i=s+1}^{I} \left( \frac{p_i}{1 - P_s} \right)^2.\]</p><p>Finding the discrete value <span>$s$</span> which maximises the function <span>$\psi(s)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">
using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img, 256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(counts[1:end], edges, Yen())</code></pre><p><strong>Reference</strong></p><ol><li>Yen JC, Chang FJ, Chang S (1995), “A New Criterion for Automatic Multilevel Thresholding”, IEEE Trans. on Image Processing 4 (3): 370-378, <a href="https://doi.org/10.1109/83.366472">doi:10.1109/83.366472</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/algorithms/yen.jl#L1-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.ThresholdAPI.find_threshold" href="#HistogramThresholding.ThresholdAPI.find_threshold"><code>HistogramThresholding.ThresholdAPI.find_threshold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_threshold(data::AbstractArray, f::AbstractThresholdAlgorithm; nbins)
find_threshold(histogram::AbstractArray, edges::AbstractArray, f::AbstractThresholdAlgorithm)</code></pre><p>Find a suitable threshold in <code>data</code> using algorithm <code>f</code> upon constructing a histogram with <code>nbins</code>. Instead of specifing the raw <code>data</code>, you can specify a histogram and accompanying edges directly. </p><p><strong>Output</strong></p><p>A real number representing a threshold that can be used to split data into two parts. </p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>find_threshold</code>:</p><pre><code class="language-julia">using TestImages, HistogramThreshold
img = testimage(&quot;cameraman&quot;)
t = find_threshold(img, f ; nbins = 64)</code></pre><pre><code class="language-julia">using StatsBase, HistogramThreshold
data = vcat(ones(50,), zeros(50,))
h = fit(Histogram, data)
t = find_threshold(data, f ; nbins = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/ThresholdAPI/find_threshold.jl#L55-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HistogramThresholding.ThresholdAPI.build_histogram" href="#HistogramThresholding.ThresholdAPI.build_histogram"><code>HistogramThresholding.ThresholdAPI.build_histogram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edges, count = build_histogram(img)            # For 8-bit images only
edges, count = build_histogram(img, nbins)
edges, count = build_histogram(img, nbins; minval, maxval)
edges, count = build_histogram(img, edges)</code></pre><p>Generates a histogram for the image over <code>nbins</code> spread between <code>[minval, maxval]</code>. Color images are automatically converted to grayscale.</p><p><strong>Output</strong></p><p>Returns <code>edges</code> which is a <code>AbstractRange</code> type that specifies how the  interval <code>[minval, maxval]</code> is divided into bins, and an array <code>count</code> which records the concomitant bin frequencies. In particular, <code>count</code> has the following properties:</p><ul><li><code>count[0]</code> is the number satisfying <code>x &lt; edges[1]</code></li><li><code>count[i]</code> is the number of values <code>x</code> that satisfy <code>edges[i] &lt;= x &lt; edges[i+1]</code></li><li><code>count[end]</code> is the number satisfying <code>x &gt;= edges[end]</code>.</li><li><code>length(count) == length(edges)+1</code>.</li></ul><p><strong>Details</strong></p><p>One can consider a histogram as a piecewise-constant model of a probability density function <span>$f$</span> [1]. Suppose that <span>$f$</span> has support on some interval <span>$I = [a,b]$</span>.  Let <span>$m$</span> be an integer and <span>$a = a_1 &lt; a_2 &lt; \ldots &lt; a_m &lt; a_{m+1} = b$</span> a sequence of real numbers. Construct a sequence of intervals</p><p class="math-container">\[I_1 = [a_1,a_2], I_2 = (a_2, a_3], \ldots, I_{m} = (a_m,a_{m+1}]\]</p><p>which partition <span>$I$</span> into subsets <span>$I_j$</span> <span>$(j = 1, \ldots, m)$</span> on which <span>$f$</span> is constant. These subsets satisfy <span>$I_i \cap I_j = \emptyset, \forall i \neq j$</span>, and are commonly referred to as <em>bins</em>. Together they encompass the entire range of data values such that <span>$\sum_j |I_j | = | I |$</span>. Each bin has width <span>$w_j = |I_j| = a_{j+1} - a_j$</span> and height <span>$h_j$</span> which is the constant probability density over the region of the bin. Integrating the constant probability density over the width of the bin <span>$w_j$</span> yields a probability mass of <span>$\pi_j = h_j w_j$</span> for the bin.</p><p>For a sample <span>$x_1, x_2, \ldots, x_N$</span>, let</p><p class="math-container">\[n_j = \sum_{n = 1}^{N}\mathbf{1}_{(I_j)}(x_n),
\quad \text{where} \quad
\mathbf{1}_{(I_j)}(x) =
\begin{cases}
 1 &amp; \text{if} \; x \in I_j,\\
 0 &amp; \text{otherwise},
\end{cases},\]</p><p>represent the number of samples falling into the interval <span>$I_j$</span>. An estimate for the probability mass of the <span>$j$</span>th bin is given by the relative frequency <span>$\hat{\pi} = \frac{n_j}{N}$</span>, and the histogram estimator of the probability density function is defined as</p><p class="math-container">\[\begin{aligned}
\hat{f}_n(x)  &amp; = \sum_{j = 1}^{m}\frac{n_j}{Nw_j} \mathbf{1}_{(I_j)}(x) \\
&amp; = \sum_{j = 1}^{m}\frac{\hat{\pi}_j}{w_j} \mathbf{1}_{(I_j)}(x) \\
&amp; = \sum_{j = 1}^{m}\hat{h}_j \mathbf{1}_{(I_j)}(x).
\end{aligned}\]</p><p>The function <span>$\hat{f}_n(x)$</span> is a genuine density estimator because <span>$\hat{f}_n(x)  \ge 0$</span> and</p><p class="math-container">\[\begin{aligned}
\int_{-\infty}^{\infty}\hat{f}_n(x) \operatorname{d}x &amp; = \sum_{j=1}^{m} \frac{n_j}{Nw_j} w_j \\
&amp; = 1.
\end{aligned}\]</p><p><strong>Options</strong></p><p>Various options for the parameters of this function are described in more detail below.</p><p><strong>Choices for <code>nbins</code></strong></p><p>You can specify the number of discrete bins for the histogram. When specifying the number of bins consider the maximum number of graylevels that your image type supports. For example, with an image of type <code>N0f8</code> there is a maximum of 256 possible graylevels. Hence, if you request more than 256 bins for that type of image you should expect to obtain zero counts for numerous bins.</p><p><strong>Choices for <code>minval</code></strong></p><p>You have the option to specify the lower bound of the interval over which the histogram will be computed.  If <code>minval</code> is not specified then the minimum value present in the image is taken as the lower bound.</p><p><strong>Choices for <code>maxval</code></strong></p><p>You have the option to specify the upper bound of the interval over which the histogram will be computed.  If <code>maxval</code> is not specified then the maximum value present in the image is taken as the upper bound.</p><p><strong>Choices for <code>edges</code></strong></p><p>If you do not designate the number of bins, nor the lower or upper bound of the interval, then you have the option to directly stipulate how the intervals will be divided by specifying a <code>AbstractRange</code> type.</p><p><strong>Example</strong></p><p>Compute the histogram of a grayscale image.</p><pre><code class="language-julia">
using TestImages, FileIO, ImageView

img =  testimage(&quot;mandril_gray&quot;);
edges, counts  = build_histogram(img, 256, minval = 0, maxval = 1)</code></pre><p>Given a color image, compute the histogram of the red channel.</p><pre><code class="language-julia">img = testimage(&quot;mandrill&quot;)
r = red.(img)
edges, counts  = build_histogram(r, 256, minval = 0, maxval = 1)</code></pre><p><strong>References</strong></p><p>[1] E. Herrholz, &quot;Parsimonious Histograms,&quot; Ph.D. dissertation, Inst. of Math. and Comp. Sci., University of Greifswald, Greifswald, Germany, 2011.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/HistogramThresholding.jl/blob/2d5691678927159d3828d8d7a31904a1670e2c3e/src/ThresholdAPI/build_histogram.jl#L29-L150">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 10 December 2021 23:26">Friday 10 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
