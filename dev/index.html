<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HistogramThresholding.jl Documentation · Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>HistogramThresholding.jl Documentation</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>HistogramThresholding.jl Documentation</a></li></ul><a class="edit-page" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>HistogramThresholding.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HistogramThresholding.jl-Documentation-1" href="#HistogramThresholding.jl-Documentation-1">HistogramThresholding.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{Otsu,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{Otsu,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(Otsu(),  histogram, edges)</code></pre><p>Under the assumption that the histogram is bimodal the threshold is set so that the resultant inter-class variance is maximal.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> that specifies the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;camerman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(Otsu(),counts[1:end], edges)</code></pre><p><strong>Reference</strong></p><ol><li>Nobuyuki Otsu (1979). &quot;A threshold selection method from gray-level histograms&quot;. <em>IEEE Trans. Sys., Man., Cyber.</em> 9 (1): 62–66. <a href="http://dx.doi.org/doi:10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/otsu.jl#L1-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{MinimumIntermodes,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{MinimumIntermodes,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(MinimumIntermodes(),  histogram, edges)</code></pre><p>Under the assumption that the histogram is bimodal the histogram is smoothed using a length-3 mean filter until two modes remain. The threshold is then set to the minimum value between the two modes.</p><p><strong>Output</strong></p><p>Returns <code>t</code>, a real number that specifies the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;camerman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(MinimumIntermodes(),counts[1:end], edges)</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/minimum.jl#L1-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{Intermodes,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{Intermodes,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(Intermodes(),  histogram, edges)</code></pre><p>Under the assumption that the histogram is bimodal the histogram is smoothed using a length-3 mean filter until two modes remain. The threshold is then set to the average value of the two modes.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> that specifies the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;camerman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">
using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(Intermodes(),counts[1:end], edges)</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/intermodes.jl#L1-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{MinimumError,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{MinimumError,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(MinimumError(),  histogram, edges)</code></pre><p>Under the assumption that the histogram is a mixture of two Gaussian distributions the threshold is chosen such that the expected misclassification error rate is minimised.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> that specifies the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;camerman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(MinimumError(),counts[1:end], edges)</code></pre><p><strong>References</strong></p><ol><li>J. Kittler and J. Illingworth, “Minimum error thresholding,” Pattern Recognition, vol. 19, no. 1, pp. 41–47, Jan. 1986. <a href="https://doi.org/10.1016/0031-3203%2886%2990030-0">doi:10.1016/0031-3203(86)90030-0</a></li><li>Q.-Z. Ye and P.-E. Danielsson, “On minimum error thresholding and its implementations,” Pattern Recognition Letters, vol. 7, no. 4, pp. 201–206, Apr. 1988. <a href="https://doi.org/10.1016/0167-8655%2888%2990103-1">doi:10.1016/0167-8655(88)90103-1</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/minimum_error.jl#L2-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{Moments,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{Moments,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(Moments(),  histogram, edges)</code></pre><p>The following rule determines the threshold:  if one assigns all observations below the threshold to a value z₀ and all observations above the threshold to a value z₁, then the first three moments of the original histogram must match the moments of this specially constructed bilevel histogram.</p><p><strong>Output</strong></p><p>Returns a real number <code>t</code> that specifies the threshold.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;camerman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;cameraman&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(Moments(),counts[1:end], edges)</code></pre><p><strong>Reference</strong></p><p>[1] W.-H. Tsai, “Moment-preserving thresolding: A new approach,” Computer Vision, Graphics, and Image Processing, vol. 29, no. 3, pp. 377–393, Mar. 1985. <a href="https://doi.org/10.1016/0734-189x%2885%2990133-1">doi:10.1016/0734-189x(85)90133-1</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/moments.jl#L1-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HistogramThresholding.find_threshold-Tuple{UnimodalRosin,AbstractArray,AbstractRange}" href="#HistogramThresholding.find_threshold-Tuple{UnimodalRosin,AbstractArray,AbstractRange}"><code>HistogramThresholding.find_threshold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = find_threshold(UnimodalRosin(), histogram, edges)</code></pre><p>Generates a threshold value for array <code>histogram</code> and interval <code>edges</code> using Rosin&#39;s algorithm.</p><p><strong>Output</strong></p><p>Returns <code>t</code>, a real number that specifies the threshold.</p><p><strong>Details</strong></p><p>This algorithm first selects the bin in the histogram with the highest frequency. The algorithm then searches from the location of the maximum bin to the last bin of the histogram for the first bin with a frequency of 0 (known as the minimum bin.). A line is then drawn that passes through both the maximum and minimum bins. The bin with the greatest orthogonal distance to the line is chosen as the threshold value.</p><p><strong>Assumptions</strong></p><p>This algorithm assumes that:</p><ul><li>The histogram is unimodal.</li><li>There is always at least one bin that has a frequency of 0. If not, the algorithm will use the last bin as the minimum bin.</li><li>If the histogram includes multiple bins with a frequency of 0, the algorithm will select the first zero bin as its minimum.</li><li>If there are multiple bins with the greatest orthogonal distance, the leftmost bin is selected as the threshold.</li></ul><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>histogram</code></strong></p><p>An <code>AbstractArray</code> storing the frequency distribution.</p><p><strong><code>edges</code></strong></p><p>An <code>AbstractRange</code> specifying how the intervals for the frequency distribution are divided.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;moonsurface&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageContrastAdjustment, HistogramThresholding

img = testimage(&quot;moonsurface&quot;)
edges, counts = build_histogram(img,256)
#=
  The `counts` array stores at index 0 the frequencies that were below the
  first bin edge. Since we are seeking a threshold over the interval
  partitioned by `edges` we need to discard the first bin in `counts`
  so that the dimensions of `edges` and `counts` match.
=#
t = find_threshold(UnimodalRosin(),counts[1:end], edges)</code></pre><p><strong>Reference</strong></p><ol><li>P. L. Rosin, “Unimodal thresholding,” Pattern Recognition, vol. 34, no. 11, pp. 2083–2096, Nov. 2001.<a href="https://doi.org/10.1016/s0031-3203%2800%2900136-9">doi:10.1016/s0031-3203(00)00136-9</a></li></ol><p><strong>See Also</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/HistogramThresholding.jl/blob/74c416a8ba5a2347c411b5810c62cc1e47239853/src/unimodal.jl#L1-L65">source</a></section><footer><hr/></footer></article></body></html>
